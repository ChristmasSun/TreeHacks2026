<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoom Bot</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
        }
        #zmmtg-root {
            display: none;
        }
        #status {
            color: white;
            font-family: monospace;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div id="status">Initializing Zoom Bot...</div>
    <div id="zmmtg-root"></div>

    <!-- Zoom Web SDK -->
    <script src="https://source.zoom.us/3.7.0/lib/vendor/react.min.js"></script>
    <script src="https://source.zoom.us/3.7.0/lib/vendor/react-dom.min.js"></script>
    <script src="https://source.zoom.us/3.7.0/lib/vendor/redux.min.js"></script>
    <script src="https://source.zoom.us/3.7.0/lib/vendor/redux-thunk.min.js"></script>
    <script src="https://source.zoom.us/3.7.0/lib/vendor/lodash.min.js"></script>
    <script src="https://source.zoom.us/zoom-meeting-3.7.0.min.js"></script>

    <script>
        const { ZoomMtg } = window;

        // Expose to window for Puppeteer communication
        window.botState = {
            status: 'initializing',
            participantId: null,
            error: null,
            audioEnabled: false,
            inBreakoutRoom: false
        };

        // Initialize Zoom SDK
        ZoomMtg.preLoadWasm();
        ZoomMtg.prepareWebSDK();

        // Audio playback system
        let audioPlaybackContext = null;
        let audioPlaybackQueue = [];
        let isPlayingAudio = false;

        window.playAudioData = async (audioBase64) => {
            try {
                if (!audioPlaybackContext) {
                    audioPlaybackContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Decode base64 to ArrayBuffer
                const binaryString = atob(audioBase64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // Decode audio data
                const audioBuffer = await audioPlaybackContext.decodeAudioData(bytes.buffer);

                // Create audio source and connect to destination
                const source = audioPlaybackContext.createBufferSource();
                source.buffer = audioBuffer;

                // Create gain node for volume control
                const gainNode = audioPlaybackContext.createGain();
                gainNode.gain.value = 1.0;

                source.connect(gainNode);
                gainNode.connect(audioPlaybackContext.destination);

                // Play audio
                source.start(0);

                return new Promise((resolve) => {
                    source.onended = () => {
                        console.log('[Bot] Audio playback finished');
                        resolve({ success: true });
                    };
                });

            } catch (error) {
                console.error('[Bot] Audio playback error:', error);
                return { success: false, error: error.message };
            }
        };

        // Event handlers
        const eventHandlers = {
            onMeetingStatus: (status) => {
                console.log('[Bot] Meeting status:', status);
                window.botState.status = status.meetingStatus;

                if (status.meetingStatus === 2) { // Connected
                    window.botState.status = 'joined';
                    document.getElementById('status').textContent = 'Bot joined meeting';
                }
            },

            onUserJoin: (data) => {
                console.log('[Bot] User joined:', data);
            },

            onUserLeave: (data) => {
                console.log('[Bot] User left:', data);
            },

            onAudioChange: (payload) => {
                console.log('[Bot] Audio change:', payload);
            },

            onActiveSpeaker: (data) => {
                console.log('[Bot] Active speaker:', data);
            }
        };

        // Join meeting function
        window.joinMeeting = async (config) => {
            try {
                console.log('[Bot] Joining meeting:', config.meetingNumber);
                console.log('[Bot] Config:', {
                    sdkKey: config.sdkKey,
                    meetingNumber: config.meetingNumber,
                    userName: config.userName,
                    hasSignature: !!config.signature,
                    hasPassword: !!config.password,
                    signatureLength: config.signature?.length
                });
                document.getElementById('status').textContent = 'Joining meeting...';

                // Set up global event listeners BEFORE init
                ZoomMtg.inMeetingServiceListener('onMeetingStatus', (data) => {
                    console.log('[Bot] Meeting status change:', data);
                    if (data.meetingStatus === 2) {
                        console.log('[Bot] CONNECTED!');
                        window.botState.status = 'joined';
                    }
                });

                console.log('[Bot] Calling ZoomMtg.init...');
                ZoomMtg.init({
                    leaveUrl: 'about:blank',
                    isSupportAV: true,
                    success: (success) => {
                        console.log('[Bot] Init success!', success);
                        console.log('[Bot] Now calling ZoomMtg.join...');

                        const joinConfig = {
                            signature: config.signature,
                            sdkKey: config.sdkKey,
                            meetingNumber: config.meetingNumber,
                            userName: config.userName,
                            passWord: config.password || '',
                            success: (res) => {
                                console.log('[Bot] ✅ JOIN SUCCESS!', res);
                                window.botState.status = 'joined';
                                window.botState.participantId = res?.result?.currentUser?.userId;
                                document.getElementById('status').textContent = 'JOINED SUCCESSFULLY!';
                            },
                            error: (err) => {
                                console.error('[Bot] ❌ JOIN ERROR!', err);
                                console.error('[Bot] Error type:', typeof err);
                                console.error('[Bot] Error keys:', Object.keys(err || {}));
                                window.botState.status = 'error';
                                window.botState.error = JSON.stringify(err);
                                document.getElementById('status').textContent = 'Join failed: ' + JSON.stringify(err);
                            }
                        };

                        console.log('[Bot] Join config prepared');
                        console.log('[Bot] Executing ZoomMtg.join NOW...');

                        setTimeout(() => {
                            try {
                                const result = ZoomMtg.join(joinConfig);
                                console.log('[Bot] ZoomMtg.join() returned:', result);
                                console.log('[Bot] Return type:', typeof result);
                            } catch (e) {
                                console.error('[Bot] EXCEPTION in ZoomMtg.join():', e);
                                window.botState.status = 'error';
                                window.botState.error = e.message;
                            }
                        }, 100);
                    },
                    error: (error) => {
                        console.error('[Bot] ❌ INIT ERROR!', error);
                        console.error('[Bot] Error details:', JSON.stringify(error, null, 2));
                        window.botState.status = 'error';
                        window.botState.error = JSON.stringify(error);
                        document.getElementById('status').textContent = 'Init failed: ' + JSON.stringify(error);
                    }
                });
            } catch (error) {
                console.error('[Bot] OUTER EXCEPTION:', error);
                window.botState.status = 'error';
                window.botState.error = error.message;
            }
        };

        // Audio control functions
        window.enableAudio = async () => {
            try {
                console.log('[Bot] Enabling audio...');
                await ZoomMtg.unmuteAudio();
                window.botState.audioEnabled = true;
                return { success: true };
            } catch (error) {
                console.error('[Bot] Failed to enable audio:', error);
                return { success: false, error: error.message };
            }
        };

        window.disableAudio = async () => {
            try {
                await ZoomMtg.muteAudio();
                window.botState.audioEnabled = false;
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        };

        // Audio capture setup
        let mediaRecorder = null;
        let audioChunks = [];
        let audioContext = null;
        let audioStreamDestination = null;

        window.startAudioCapture = async () => {
            try {
                // Get audio stream from Zoom
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // Create audio context for processing
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(stream);
                audioStreamDestination = audioContext.createMediaStreamDestination();
                source.connect(audioStreamDestination);

                // Start recording
                mediaRecorder = new MediaRecorder(audioStreamDestination.stream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 16000
                });

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        // Convert to base64 and store
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            const base64 = reader.result.split(',')[1];
                            if (!window.audioChunksBuffer) {
                                window.audioChunksBuffer = [];
                            }
                            window.audioChunksBuffer.push({
                                data: base64,
                                timestamp: Date.now(),
                                size: event.data.size
                            });
                        };
                        reader.readAsDataURL(event.data);
                    }
                };

                // Record in 1-second chunks for real-time processing
                mediaRecorder.start(1000);
                console.log('[Bot] Audio capture started');
                return { success: true };

            } catch (error) {
                console.error('[Bot] Failed to start audio capture:', error);
                return { success: false, error: error.message };
            }
        };

        window.stopAudioCapture = () => {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
        };

        window.getAudioChunks = () => {
            const chunks = window.audioChunksBuffer || [];
            window.audioChunksBuffer = [];
            return chunks;
        };

        // Leave meeting
        window.leaveMeeting = async () => {
            try {
                console.log('[Bot] Leaving meeting...');
                await ZoomMtg.leaveMeeting();
                window.botState.status = 'disconnected';
                return { success: true };
            } catch (error) {
                console.error('[Bot] Failed to leave:', error);
                return { success: false, error: error.message };
            }
        };

        // Join breakout room
        window.joinBreakoutRoom = async (roomId) => {
            try {
                console.log('[Bot] Joining breakout room:', roomId);
                // Note: Zoom Web SDK has limited breakout room API
                // This may require host to assign bot to room
                window.botState.inBreakoutRoom = true;
                return { success: true };
            } catch (error) {
                console.error('[Bot] Failed to join breakout room:', error);
                return { success: false, error: error.message };
            }
        };

        console.log('[Bot] Ready for commands');
    </script>
</body>
</html>
